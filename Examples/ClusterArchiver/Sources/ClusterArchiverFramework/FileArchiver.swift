import Flynn
import Foundation

class FileArchiver: Actor {
    private var inputURL: URL = URL(fileURLWithPath: "/dev/null")
    private var outputURL: URL = URL(fileURLWithPath: "/dev/null")
    private var isLocal: Bool
    private let bufferSize = 16384 * 4

    private var lzipActor: LzipActor?
    private var chunksOutstanding = 0

    init(file: URL, local: Bool) {
        inputURL = file
        isLocal = local

        super.init()
    }

    private func fail(_ reason: String,
                      _ returnCallback: @escaping (Bool) -> Void) {
        print("\(reason): \(inputURL)")
        lzipActor = nil
        returnCallback(false)
    }

    private func _beArchive(_ returnCallback: @escaping (Bool) -> Void) {
        FileIO.shared.beOpenRead(inputURL)

        FileIO.shared.beRead(inputURL, bufferSize, self) {
            guard let data = $0 else { return self.fail("First chunk is null", returnCallback) }
            self.processFirstChunk(data, returnCallback)
        }
    }

    private func processFirstChunk(_ nextChunk: Data,
                                   _ returnCallback: @escaping (Bool) -> Void) {
        // Read the first bit from the file to know if it is compressed lzip or not
        guard nextChunk.count > 0 else { return fail("First chunk is empty", returnCallback) }

        if nextChunk.isLzipped {
            outputURL = inputURL.deletingPathExtension()
        } else {
            outputURL = inputURL.appendingPathExtension("lz")
        }
        FileIO.shared.beOpenWrite(outputURL)

        if isLocal {
            if nextChunk.isLzipped {
                lzipActor = LocalDecompressor()
            } else {
                lzipActor = LocalCompressor()
            }
        } else {
            if nextChunk.isLzipped {
                lzipActor = RemoteDecompressor()
            } else {
                lzipActor = RemoteCompressor()
            }
        }

        processNextChunk(nextChunk,
                         returnCallback)
    }

    private func processNextChunk(_ nextChunk: Data,
                                  _ returnCallback: @escaping (Bool) -> Void) {
        guard lzipActor != nil else { return }
        guard chunksOutstanding < 3 else { return }

        // Check to see if we sent all of the data
        if nextChunk.count == 0 {
            return finished(returnCallback)
        }

        if let lzipActor = lzipActor {
            chunksOutstanding += 1
            lzipActor.beArchive(nextChunk, self) { (resultData) in
                FileIO.shared.beWrite(self.outputURL, resultData)

                self.chunksOutstanding -= 1

                if self.lzipActor != nil {
                    FileIO.shared.beRead(self.inputURL, self.bufferSize, self) {
                        guard let data = $0 else { return }
                        self.processNextChunk(data, returnCallback)
                    }
                }
            }
        }

        FileIO.shared.beRead(self.inputURL, bufferSize, self) {
            guard let data = $0 else { return }
            self.processNextChunk(data, returnCallback)
        }
    }

    private func finished(_ returnCallback: @escaping (Bool) -> Void) {
        if let lzipActor = lzipActor {
            FileIO.shared.beClose(inputURL)

            lzipActor.beFinish(self) { (resultData) in
                FileIO.shared.beWrite(self.outputURL, resultData)
                FileIO.shared.beClose(self.outputURL)

                try? FileManager.default.removeItem(at: self.inputURL)
                returnCallback(true)
            }
            self.lzipActor = nil
        }
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension FileArchiver {

    @discardableResult
    public func beArchive(_ sender: Actor,
                          _ callback: @escaping ((Bool) -> Void)) -> Self {
        unsafeSend {
            self._beArchive { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }

}

extension FileIO {

}

extension Archiver {

}
