// swiftlint:disable unused_optional_binding

import Flynn
import Foundation

class FileArchiver: Actor {
    private var fileHandle: FileHandle?
    private var fileURL: URL
    private var isLocal: Bool
    private let bufferSize = 16384 * 4

    private var lzipActor: LzipActor?
    private var nextChunk = Data()
    private var chunksOutstanding = 0

    init(file: URL, local: Bool) {
        fileURL = file
        isLocal = local

        super.init()

        fileHandle = try? FileHandle(forReadingFrom: file)
    }

    private func fail(_ reason: String,
                      _ returnCallback: @escaping (Bool) -> Void) {
        print("\(reason): \(fileURL)")
        lzipActor = nil
        returnCallback(false)
    }

    private func _beArchive(_ returnCallback: @escaping (Bool) -> Void) {
        guard let fileHandle = fileHandle else { return fail("FileHandle is null", returnCallback) }

        // Read the first bit from the file to know if it is compressed lzip or not
        nextChunk = fileHandle.readData(ofLength: bufferSize)
        guard nextChunk.count > 0 else { return fail("First chunk is empty", returnCallback) }

        if isLocal {
            if nextChunk.isLzipped {
                lzipActor = LocalDecompressor()
            } else {
                lzipActor = LocalCompressor()
            }
        } else {
            if nextChunk.isLzipped {
                lzipActor = RemoteDecompressor()
            } else {
                lzipActor = RemoteCompressor()
            }
        }

        processNextChunk(returnCallback)
    }

    private func processNextChunk(_ returnCallback: @escaping (Bool) -> Void) {
        guard lzipActor != nil else { return }
        guard let fileHandle = fileHandle else { return fail("FileHandle is null", returnCallback) }

        while chunksOutstanding < 4 {

            // Check to see if we sent all of the data
            if nextChunk.count == 0 {
                return finished(returnCallback)
            }

            if let lzipActor = lzipActor {
                chunksOutstanding += 1
                lzipActor.beArchive(nextChunk, self) { (result) in
                    guard result == true else { return self.fail("Lzip returned false", returnCallback) }
                    self.chunksOutstanding -= 1
                    self.processNextChunk(returnCallback)
                }
            }

            nextChunk = fileHandle.readData(ofLength: bufferSize)
        }
    }

    private func finished(_ returnCallback: @escaping (Bool) -> Void) {
        if let lzipActor = lzipActor {
            lzipActor.beFinish(self) { (data) in
                if data.count > 0 {
                    if data.isLzipped {
                        let outFile = self.fileURL.appendingPathExtension("lz")
                        if let _ = try? data.write(to: outFile) {
                            try? FileManager.default.removeItem(at: self.fileURL)
                        }
                    } else {
                        let outFile = self.fileURL.deletingPathExtension()
                        if let _ = try? data.write(to: outFile) {
                            try? FileManager.default.removeItem(at: self.fileURL)
                        }
                    }
                    returnCallback(true)
                } else {
                    return self.fail("RemoteDecompressor finish empty data", returnCallback)
                }
            }
            self.lzipActor = nil
        }
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension FileArchiver {

    @discardableResult
    public func beArchive(_ sender: Actor,
                          _ callback: @escaping ((Bool) -> Void)) -> Self {
        unsafeSend {
            self._beArchive { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }

}

extension Archiver {

}
