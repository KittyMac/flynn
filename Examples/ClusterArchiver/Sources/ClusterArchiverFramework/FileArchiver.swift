import Flynn
import Foundation

class FileArchiver: Actor {
    private var inputURL: URL = URL(fileURLWithPath: "/dev/null")
    private var outputURL: URL = URL(fileURLWithPath: "/dev/null")
    private var isLocal: Bool
    private let bufferSize = 65536 * 2
    private var lzipActor: LzipActor?
    private var outstandingChunks = 0
    private var bytesProcessed: Int = 0

    init(file: URL, local: Bool) {
        inputURL = file
        isLocal = local

        super.init()
    }

    private func fail(_ reason: String,
                      _ returnCallback: @escaping (Bool) -> Void) {
        print("\(reason): \(inputURL)")
        lzipActor = nil
        returnCallback(false)
    }

    private func _beArchive(_ returnCallback: @escaping (Bool) -> Void) {
        FileIO.shared.beOpenRead(inputURL)

        FileIO.shared.beRead(inputURL, bufferSize, self) {
            guard let data = $0 else { return self.fail("First chunk is null", returnCallback) }
            self.processFirstChunk(data, returnCallback)
        }
    }

    private func processFirstChunk(_ nextChunk: Data,
                                   _ returnCallback: @escaping (Bool) -> Void) {
        // Read the first bit from the file to know if it is compressed lzip or not
        guard nextChunk.count > 0 else { return fail("First chunk is empty", returnCallback) }

        if nextChunk.isLzipped {
            outputURL = inputURL.deletingPathExtension()
        } else {
            outputURL = inputURL.appendingPathExtension("lz")
        }
        FileIO.shared.beOpenWrite(outputURL)

        if isLocal {
            if nextChunk.isLzipped {
                lzipActor = LocalDecompressor()
            } else {
                lzipActor = LocalCompressor()
            }
        } else {
            if nextChunk.isLzipped {
                lzipActor = RemoteDecompressor()
            } else {
                lzipActor = RemoteCompressor()
            }
        }

        processNextChunk(nextChunk,
                         returnCallback)
    }

    private func processNextChunk(_ nextChunk: Data,
                                  _ returnCallback: @escaping (Bool) -> Void) {
        guard let lzipActor = lzipActor else { return }

        let readMore: (() -> Void) = {
            while self.outstandingChunks < 8 {
                self.outstandingChunks += 1
                FileIO.shared.beRead(self.inputURL, self.bufferSize, self) {
                    guard let data = $0 else { return }
                    self.processNextChunk(data, returnCallback)
                }
            }
        }

        if nextChunk.count == 0 {
            return finished(returnCallback)
        }

        lzipActor.beArchive(nextChunk, self) { (resultData) in
            self.outstandingChunks -= 1
            self.bytesProcessed += resultData.count

            FileIO.shared.beWrite(self.outputURL, resultData)
            if self.lzipActor != nil {
                readMore()
            }
        }

        readMore()
    }

    private func finished(_ returnCallback: @escaping (Bool) -> Void) {
        if let lzipActor = lzipActor {
            FileIO.shared.beClose(inputURL)

            lzipActor.beFinish(self) { (resultData) in
                FileIO.shared.beWrite(self.outputURL, resultData)
                FileIO.shared.beClose(self.outputURL)

                if self.bytesProcessed > 0 {
                    try? FileManager.default.removeItem(at: self.inputURL)
                } else {
                    print("failed to process file \(self.outputURL.path)")
                    try? FileManager.default.removeItem(at: self.outputURL)
                }
                returnCallback(true)
            }
            self.lzipActor = nil
        }
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension FileArchiver {

    @discardableResult
    public func beArchive(_ sender: Actor,
                          _ callback: @escaping ((Bool) -> Void)) -> Self {
        unsafeSend {
            self._beArchive { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }

}

extension FileIO {

}

extension Archiver {

}
