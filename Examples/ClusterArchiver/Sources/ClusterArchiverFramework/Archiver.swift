// swiftlint:disable unused_optional_binding

import Flynn
import Foundation

private class FileArchiver: Actor {
    private func _beArchive(file: URL, _ returnCallback: @escaping (Bool) -> Void) {
        guard let data = try? Data(contentsOf: file) else { return returnCallback(false) }

        let support = Support()
        support.beArchive(data, self) { (result) in
            if result.isLzipped {
                let outFile = file.appendingPathExtension("lz")
                if let _ = try? result.write(to: outFile) {
                    try? FileManager.default.removeItem(at: file)
                }
            } else {
                let outFile = file.deletingPathExtension()
                if let _ = try? result.write(to: outFile) {
                    try? FileManager.default.removeItem(at: file)
                }
            }

            return returnCallback(true)
        }
    }
}

public class Archiver: Actor {

    private var files: [URL] = []
    private var maxActive: Int = 0
    private var active: Int = 0
    private var completed: Int = 0
    private var done = false
    private let start = Date()

    @discardableResult
    public init(directory: String) {
        super.init()

        if let directoryFiles = try? FileManager.default.contentsOfDirectory(atPath: directory) {
            for filePath in directoryFiles {
                files.append(URL(fileURLWithPath: "\(directory)/\(filePath)"))
            }

            print("\(files.count) files to process")

            beArchiveMore()
        }
    }

    private func checkDone() {
        if active == 0 && done == false {
            done = true

            print("\(completed) files in \(abs(start.timeIntervalSinceNow))s, max concurrent \(maxActive)")
        }
    }

    private func _beArchiveMore() {
        // TODO: Rework this so that it processes files in discrete
        // chunks to keep memory usage at a minimum

        // Ensure we have as many files being archived as we have cores to process on
        while active < (Flynn.remoteCores + Flynn.cores) {
            // 0. pop the next file url from files
            guard let file = files.popLast() else { return checkDone() }

            active += 1
            if active > maxActive {
                maxActive = active
            }

            let fileArchiver = FileArchiver()
            fileArchiver.beArchive(file: file, self) { (_) in
                self.active -= 1
                self.completed += 1

                self.beArchiveMore()
            }
        }
    }
}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension FileArchiver {

    @discardableResult
    public func beArchive(file: URL,
                          _ sender: Actor,
                          _ callback: @escaping ((Bool) -> Void)) -> Self {
        unsafeSend {
            self._beArchive(file: file) { arg0 in
                sender.unsafeSend {
                    callback(arg0)
                }
            }
        }
        return self
    }

}

extension Archiver {

    @discardableResult
    public func beArchiveMore() -> Self {
        unsafeSend(_beArchiveMore)
        return self
    }

}
