import Flynn
import Foundation

class FileIO: Actor {
    // We consolidate all file IO to a single actor, so at worst
    // we are locking up one thread for accessing the file system.
    static let shared = FileIO()
    private override init() {
        super.init()

        unsafePriority = 99
    }

    private func _beRemove(_ url: URL) {
        try? FileManager.default.removeItem(at: url)
    }

    private var openRead: [URL: FileHandle] = [:]
    private var openWrite: [URL: FileHandle] = [:]

    private func _beOpenRead(_ url: URL) {
        if let handle = try? FileHandle(forReadingFrom: url) {
            openRead[url] = handle
        }
    }

    private func _beOpenWrite(_ url: URL) {
        FileManager.default.createFile(atPath: url.path, contents: nil, attributes: nil)
        if let handle = try? FileHandle(forWritingTo: url) {
            openWrite[url] = handle
        }
    }

    private func _beClose(_ url: URL) {
        if let handle = openRead[url] {
            openRead[url] = nil
            handle.closeFile()
        }
        if let handle = openWrite[url] {
            openWrite[url] = nil
            handle.closeFile()
        }
    }

    private func _beRead(_ url: URL, _ count: Int) -> Data? {
        if let handle = openRead[url] {
            return handle.readData(ofLength: count)
        }
        return nil

    }

    private func _beWrite(_ url: URL, _ data: Data) {
        if let handle = openWrite[url] {
            return handle.write(data)
        }
    }

    private func _beDelete(_ url: URL) {
        _beClose(url)
        try? FileManager.default.removeItem(at: url)
    }

}

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension FileIO {

    @discardableResult
    public func beRemove(_ url: URL) -> Self {
        unsafeSend { self._beRemove(url) }
        return self
    }
    @discardableResult
    public func beOpenRead(_ url: URL) -> Self {
        unsafeSend { self._beOpenRead(url) }
        return self
    }
    @discardableResult
    public func beOpenWrite(_ url: URL) -> Self {
        unsafeSend { self._beOpenWrite(url) }
        return self
    }
    @discardableResult
    public func beClose(_ url: URL) -> Self {
        unsafeSend { self._beClose(url) }
        return self
    }
    @discardableResult
    public func beRead(_ url: URL,
                       _ count: Int,
                       _ sender: Actor,
                       _ callback: @escaping ((Data?) -> Void)) -> Self {
        unsafeSend {
            let result = self._beRead(url, count)
            sender.unsafeSend { callback(result) }
        }
        return self
    }
    @discardableResult
    public func beWrite(_ url: URL,
                        _ data: Data) -> Self {
        unsafeSend { self._beWrite(url, data) }
        return self
    }
    @discardableResult
    public func beDelete(_ url: URL) -> Self {
        unsafeSend { self._beDelete(url) }
        return self
    }

}

extension FileArchiver {

}

extension Archiver {

}
