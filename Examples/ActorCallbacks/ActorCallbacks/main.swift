import Flynn
import Foundation

struct Monster {
    var name: String
    var hitpoints: Int
    var strength: Int
    var dexterity: Int
    var intelligence: Int
}

class Scenario1: Actor, ConcurrentDatastoreRetrievable {
    private let monsters: ConcurrentDatastore

    init(_ monsters: ConcurrentDatastore) {
        self.monsters = monsters
        super.init()
    }

    private func _beRetrieveValue(_ key: String, _ value: Any?) {
        if let value = value {
            print("\(value)")
        }
    }

    private func _bePrint(_ name: String) {
        // retrieves value from storage using protocol and a callback actor
        // who adheres to a protocol defining the behavior to callback on
        monsters.beGet(name, self)
    }
}

class Scenario2: Actor {
    private let monsters: ConcurrentDatastore

    init(_ monsters: ConcurrentDatastore) {
        self.monsters = monsters
        super.init()
    }

    private func _bePrint(_ name: String) {
        // retrieves value from storage using protocol and closure. It is
        // important that ConcurrentDatastore is implemented to correctly
        // wrap the closure in unsafeSend {} to ensure it executes on
        // Scenario2 in a concurrency safe manner
        monsters.beGet(name, self) { value in
            if let value = value {
                print("\(value)")
            }
        }
    }

}

let monsters = ConcurrentDatastore()

monsters.beSet("Goblin", Monster(name: "Goblin", hitpoints: 10, strength: 3, dexterity: 2, intelligence: 1))
monsters.beSet("Orc", Monster(name: "Orc", hitpoints: 15, strength: 6, dexterity: 4, intelligence: 2))
monsters.beSet("Troll", Monster(name: "Troll", hitpoints: 30, strength: 4, dexterity: 1, intelligence: 5))

let scenario1 = Scenario1(monsters)
let scenario2 = Scenario2(monsters)

scenario1.bePrint("Goblin")
scenario1.bePrint("Orc")
scenario1.bePrint("Troll")

sleep(1)
print("--------------")

scenario2.bePrint("Troll")
scenario2.bePrint("Orc")
scenario2.bePrint("Goblin")

Flynn.shutdown()

// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension Scenario2 {

    @discardableResult
    public func bePrint(_ name: String) -> Self {
        unsafeSend { self._bePrint(name) }
        return self
    }

}

extension Scenario1 {

    @discardableResult
    public func beRetrieveValue(_ key: String, _ value: Any?) -> Self {
        unsafeSend { self._beRetrieveValue(key, value) }
        return self
    }
    @discardableResult
    public func bePrint(_ name: String) -> Self {
        unsafeSend { self._bePrint(name) }
        return self
    }

}
