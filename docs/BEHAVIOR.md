## Behaviors

Behaviors are asynchronous method calls for Actors. For 100% safe concurrency, behaviors should be the only mechanism for interacting with an Actor or an Actor's internal state.

The design direction for behaviors favors their ease of use at the call site, shifting any burden involved with writing behaviors to the Actor side.


## Deconstructing a Behavior

```swift
class HelloWorld: Actor {
    private func _bePrint(_ string: String) {
        print(string)
    }
}
```

With Flynn, our goal is to make it simple and elegant for you to write behaviors. By now, you've probably seen the example above followed by some other code which magically calls it, like this:

```swift
HelloWorld().bePrint("asynchronous: hello world")
```

This bit of magic is provided by FlynnLint, which will automatically generate an extension on HelloWorld and populate it with "wrapper functions" for your behaviors.  These extensions are automatically added to the bottom of the file the Actor is defined in, and they look like this:

```
// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension HelloWorld {

    @discardableResult
    public func bePrint(_ string: String) -> Self {
        unsafeSend { self._bePrint(string) }
        return self
    }

}
```

As you can see, when we call bePrint() it immediately calls ```unsafeSend()``` on the actor. Unsafe send wraps up the provided closure into an actor message which is placed in the actor's message queue. At some point in the future the message will be processed, and the closure will execute, calling _bePrint() and passing through the parameters.  You are not required to use FlynnLint, and as such could write these extensions yourself.

It is our hope that a future version of Swift will incorporate support for function wrappers, and the autogeneration of these wrapper functions will become unecessary.  Until then, this mechanism provides the best value in terms of performance, safety (both concurrency and type safety), and convenience.

In Flynn, we refer to the ```private func _bePrint(_ string: String)``` definition as the **internal behavior**.  The wrapper function ```public func bePrint(_ string: String) -> Self``` is referred to as the **external behavior**.  For FlynnLint to automatically generate external behaviors for your internal behaviors, your internal behaviors must start with the naming convention "**_be**"

## Behaviors are chainable

Notice above that the external behavior will return self. This allows for each chaining of behaviors on an actor, such as the following:

```
func processImage() {
    Image().beLoad("/tmp/image.png)
           .beResize(512,512)
           .beBlackAndWhite()
           .beSave("/tmp/new_image.png")
}
```

Note that once an actor is scheduled, it will be retained by the Flynn runtime until it reaches quiescence.

An individual actor is quiescent when:

- it has an empty message queue
- no strong references to the actor remain

Once an actor reaches quiescence, it will be deallocated. So in our example above, the Image actor will be created and four behaviors will be called (generating four messages in the Image actor's queue).  The processImage() function will finish, and the local scope reference to Image will go away. However, since the actor is now scheduled with the Flynn runtime, it will stay alive until all of its messages have been processed. Once it reaches quiescence, it will be deallocated.


## Interactions of Actor, Behavior and Scheduler

When a behavior is called a message is created and stored in an Actor's message queue.  The actor message contains the closure which was passed to unsafeSend(). If the actor's queue was empty when the message was added, then the actor is scheduled to be executed.  When the actor executes, it processes the actor's waiting messages.  It will process up to ```unsafeMessageBatchSize``` messages (defaults to 1000) or end early if any behavior calls ```unsafeYield()``` while it is running.  If there are more messages left in the actor's queue when it finished its run, it will be rescheduled to run again sometime in the future.

**Note: Actor's have an unlimited message queue size!**

This interaction is important to note in terms of architecting your network of actors. Let's say you have an actor which reads data from a very large file in small sized chunks. You send each chunk to a processing actor. The code the processing actor runs is quite slow, at least compared to the file reading actor. If left unchecked, the reading actor will likely read in the entire file and send all chunks to the processing actor before it has a chance to process many of them. This means the entire file is now in memory, in small sized chunks, in individual messages in the processing actor's message queue.  If this behavior is undesirable, you need to code your produced such that it does not overwhelm the consumer (by using (perhaps by using a combination of ```unsafeMessagesCount``` and ```unsafeYield()``` ).

## Calling back to another actor

As we know, actors are concurrency safe classes whose internals cannot be directly accessed from outside of the class. So if an actor needs a value from a different actor, how can it retrieve values concurrently using behaviors?

All of these examples are in the [Actor Callbacks Example](../Examples/ActorCallbacks) project.

### Secnario 1

In this scenario we want to create a generic API callback from one actor to some other actor.  In short, we send the callback actor to a behavior, and that actor needs to adhere to a protocol which defines the behavior we expect to callback to. This scenario works well for actor collaboration which follows specific, modular, well defined paths.

```swift
protocol ConcurrentDatastoreRetrievable {
    @discardableResult
    func beRetrieveValue(_ key: String, _ value: Any?) -> Self
}

class ConcurrentDatastore: Actor {
    private var storage: [String: Any?] = [:]

    private func _beGet(_ key: String, _ sender: ConcurrentDatastoreRetrievable) {
        if let value = storage[key] {
            sender.beRetrieveValue(key, value)
        }
    }

    private func _beSet(_ key: String, _ value: Any?) {
        storage[key] = value
    }

}
```

```swift
class Scenario1: Actor, ConcurrentDatastoreRetrievable {
    private let monsters: ConcurrentDatastore

    init(_ monsters: ConcurrentDatastore) {
        self.monsters = monsters
        super.init()
    }

    private func _beRetrieveValue(_ key: String, _ value: Any?) {
        if let value = value {
            print("\(value)")
        }
    }

    private func _bePrint(_ name: String) {
        // retrieves value from storage using protocol and a callback actor
        // who adheres to a protocol defining the behavior to callback on
        monsters.beGet(name, self)
    }
}
```

### Secnario 2

In this scenario, we want to be able use the retrieved information without the rigid structure. To do this we want to pass a closure to ConcurrentDatastore, the contents of which will utilized the retrieved information. The closure in this case becomes the behavior we want to be called. However, the onus is on ConcurrentDatastore to call it correctly. ConcurrentDatastore cannot just execute the closure, as it will then run the contents of the closure on ConcurrentDatastore actor's "thread", potentially while the Scenario actor's "thread" is also running.  All ConcurrentDatastore needs to do is wrap the call to the closure with unsafeSend {}, which will ensure the closure runs on the Scenario actor, just as if the closure was a fully-defined behavior.

```swift
class ConcurrentDatastore: Actor {
    private var storage: [String: Any?] = [:]

    private func _beGet(_ key: String, _ sender: Actor, _ block: @escaping (Any?) -> Void) {
        if let value = storage[key] {
            // This unsafeSend is critical. If we just call the closure directly, then
            // it will execute on the ConcurrentDatastore Actor's "thread" and it could
            // lead to the sending actor running on two threads at the same time. By
            // calling unsafeSend, the closure executes as if it were a behavior, so the
            // closure will execute safely on the sending actor.
            sender.unsafeSend {
                block(value)
            }
        }
    }

    private func _beSet(_ key: String, _ value: Any?) {
        storage[key] = value
    }

}
```

```swift
class Scenario2: Actor {
    private let monsters: ConcurrentDatastore

    init(_ monsters: ConcurrentDatastore) {
        self.monsters = monsters
        super.init()
    }

    private func _bePrint(_ name: String) {
        // retrieves value from storage using protocol and closure. It is
        // important that ConcurrentDatastore is implemented to correctly
        // wrap the closure in unsafeSend {} to ensure it executes on
        // Scenario2 in a concurrency safe manner
        monsters.beGet(name, self) { value in
            if let value = value {
                print("\(value)")
            }
        }
    }
}
```