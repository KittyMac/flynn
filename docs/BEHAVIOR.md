## Behaviors

Behaviors are asynchronous method calls for Actors. For 100% safe concurrency, behaviors should be the only mechanism for interacting with an Actor or an Actor's internal state.

The design direction for behaviors favors their ease of use at the call site, shifting any burden involved with writing behaviors to the Actor side.


## Deconstructing a Behavior

```swift
class HelloWorld: Actor {
    private func _bePrint(_ string: String) {
        print(string)
    }
}
```

With Flynn, our goal is to make it simple and elegant for you to write behaviors. By now, you've probably seen the example above followed by some other code which magically calls it, like this:

```swift
HelloWorld().bePrint("asynchronous: hello world")
```

This bit of magic is provided by FlynnLint, which will automatically generate an extension on HelloWorld and populate it with "wrapper functions" for your behaviors.  These extensions ar automatically added to the bottom of the file the Actor is defined in, and they look like this:

```
// MARK: - Autogenerated by FlynnLint
// Contents of file after this marker will be overwritten as needed

extension HelloWorld {

    @discardableResult
    public func bePrint(_ string: String) -> Self {
        unsafeSend { self._bePrint(string) }
        return self
    }

}
```

As you can see, when we call bePrint() it immediately calls ```unsafeSend()``` on the actor. Unsafe send wraps up the provided closure into an actor message which is placed in the actor's message queue. At some point in the future the message will be processed, and the closure will execute, calling _bePrint() and passing through the parameters.  You are not required to use FlynnLint, and as such could write these extensions yourself.

It is our hope that a future version of Swift will incorporate support for function wrappers, and the autogeneration of these wrapper functions will become unecessary.  Until then, this mechanism provides the best value in terms of performance, safety (both concurrency and type safety), and convenience.

In Flynn, we refer to the ```private func _bePrint(_ string: String)``` definition as the **internal behavior**.  The wrapper function ```public func bePrint(_ string: String) -> Self``` is referred to as the **external behavior**.  For FlynnLint to automatically generate external behaviors for your internal behaviors, your internal behaviors must start with the naming convention "**_be**"

## Behaviors are chainable

Notice above that the external behavior will return self. This allows for each chaining of behaviors on an actor, such as the following:

```
func processImage() {
    Image().beLoad("/tmp/image.png)
           .beResize(512,512)
           .beBlackAndWhite()
           .beSave("/tmp/new_image.png")
}
```

Note that once an actor is scheduled, it will be retained by the Flynn runtime until it reaches quiescence.

An individual actor is quiescent when:

- it has an empty message queue
- no string references to the actor remain

Once an actor reaches quiescence, it will be deallocated. So in our example above, the Image actor will be created and four behaviors will be called (generating four messages in the Image actor's queue).  The processImage() function will finish, and the local scope reference to Image will go away. However, since the actor is now scheduled with the Flynn runtime, it will stay alive until all of its messages have been processed. Once it reaches quiescence, it will be deallocated.


## Interactions of Actor, Behavior and Scheduler

When a behavior is called a message is created and stored in an Actor's message queue.  The actor message contains the closure which was passed to unsafeSend(). If the actor's queue was empty when the message was added, then the actor is scheduled to be executed.  When the actor executes, it processes the actor's waiting messages.  It will process up to ```unsafeMessageBatchSize``` messages (defaults to 1000) or end early if any behavior calls ```unsafeYield()``` while it is running.  If there are more messages left in the actor's queue when it finished its run, it will be rescheduled to run again sometime in the future.

**Note: Actor's have an unlimited message queue size!**

This interaction is important to note in terms of architecting your network of actors. Let's say you have an actor which reads data from a very large file in small sized chunks. You send each chunk to a processing actor. The code the processing actor runs is quite slow, at least compared to the file reading actor. If left unchecked, the reading actor will likely read in the entire file and send all chunks to the processing actor before it has a chance to process many of them. This means the entire file is now in memory, in small sized chunks, in individual messages in the processing actor's message queue.  If this behavior is undesirable, you need to code your produced such that it does not overwhelm the consumer (by using (perhaps by using a combination of ```unsafeMessagesCount``` and ```unsafeYield()``` ).

